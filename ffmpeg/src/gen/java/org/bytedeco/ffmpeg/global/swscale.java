// Targeted by JavaCPP version 1.5.13-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.ffmpeg.global;

import org.bytedeco.ffmpeg.swscale.*;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;
import org.bytedeco.ffmpeg.avutil.*;
import static org.bytedeco.ffmpeg.global.avutil.*;

public class swscale extends org.bytedeco.ffmpeg.presets.swscale {
    static { Loader.load(); }

// Parsed from <libswscale/swscale.h>

/*
 * Copyright (C) 2024 Niklas Haas
 * Copyright (C) 2001-2011 Michael Niedermayer <michaelni@gmx.at>
 *
 * This file is part of FFmpeg.
 *
 * FFmpeg is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * FFmpeg is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with FFmpeg; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

// #ifndef SWSCALE_SWSCALE_H
// #define SWSCALE_SWSCALE_H

/**
 * \file
 * \ingroup libsws
 * external API header
 */

// #include <stdint.h>

// #include "libavutil/avutil.h"
// #include "libavutil/frame.h"
// #include "libavutil/log.h"
// #include "libavutil/pixfmt.h"
// #include "version_major.h"
// #ifndef HAVE_AV_CONFIG_H
/* When included as part of the ffmpeg build, only include the major version
 * to avoid unnecessary rebuilds. When included externally, keep including
 * the full version information. */
// #include "version.h"
// #endif

/**
 * \defgroup libsws libswscale
 * Color conversion and scaling library.
 *
 * \{
 *
 * Return the LIBSWSCALE_VERSION_INT constant.
 */
@NoException public static native @Cast("unsigned") int swscale_version();

/**
 * Return the libswscale build-time configuration.
 */
@NoException public static native @Cast("const char*") BytePointer swscale_configuration();

/**
 * Return the libswscale license.
 */
@NoException public static native @Cast("const char*") BytePointer swscale_license();

/**
 * Get the AVClass for SwsContext. It can be used in combination with
 * AV_OPT_SEARCH_FAKE_OBJ for examining options.
 *
 * @see av_opt_find().
 */
@NoException public static native @Const AVClass sws_get_class();

/******************************
 * Flags and quality settings *
 ******************************/

/** enum SwsDither */
public static final int
    SWS_DITHER_NONE = 0, /* disable dithering */
    SWS_DITHER_AUTO = 1,     /* auto-select from preset */
    SWS_DITHER_BAYER = 2,    /* ordered dither matrix */
    SWS_DITHER_ED = 3,       /* error diffusion */
    SWS_DITHER_A_DITHER = 4, /* arithmetic addition */
    SWS_DITHER_X_DITHER = 5, /* arithmetic xor */
    SWS_DITHER_NB = 6;       /* not part of the ABI */

/** enum SwsAlphaBlend */
public static final int
    SWS_ALPHA_BLEND_NONE = 0,
    SWS_ALPHA_BLEND_UNIFORM = 1,
    SWS_ALPHA_BLEND_CHECKERBOARD = 2,
    SWS_ALPHA_BLEND_NB = 3;  /* not part of the ABI */

/** enum SwsFlags */
public static final int
    /**
     * Scaler selection options. Only one may be active at a time.
     */
    /** fast bilinear filtering */
    SWS_FAST_BILINEAR = 1 <<  0,
    /** bilinear filtering */
    SWS_BILINEAR      = 1 <<  1,
    /** 2-tap cubic B-spline */
    SWS_BICUBIC       = 1 <<  2,
    /** experimental */
    SWS_X             = 1 <<  3,
    /** nearest neighbor */
    SWS_POINT         = 1 <<  4,
    /** area averaging */
    SWS_AREA          = 1 <<  5,
    /** bicubic luma, bilinear chroma */
    SWS_BICUBLIN      = 1 <<  6,
    /** gaussian approximation */
    SWS_GAUSS         = 1 <<  7,
    /** unwindowed sinc */
    SWS_SINC          = 1 <<  8,
    /** 3-tap sinc/sinc */
    SWS_LANCZOS       = 1 <<  9,
    /** cubic Keys spline */
    SWS_SPLINE        = 1 << 10,

    /**
     * Return an error on underspecified conversions. Without this flag,
     * unspecified fields are defaulted to sensible values.
     */
    SWS_STRICT        = 1 << 11,

    /**
     * Emit verbose log of scaling parameters.
     */
    SWS_PRINT_INFO    = 1 << 12,

    /**
     * Perform full chroma upsampling when upscaling to RGB.
     *
     * For example, when converting 50x50 yuv420p to 100x100 rgba, setting this flag
     * will scale the chroma plane from 25x25 to 100x100 (4:4:4), and then convert
     * the 100x100 yuv444p image to rgba in the final output step.
     *
     * Without this flag, the chroma plane is instead scaled to 50x100 (4:2:2),
     * with a single chroma sample being reused for both of the horizontally
     * adjacent RGBA output pixels.
     */
    SWS_FULL_CHR_H_INT = 1 << 13,

    /**
     * Perform full chroma interpolation when downscaling RGB sources.
     *
     * For example, when converting a 100x100 rgba source to 50x50 yuv444p, setting
     * this flag will generate a 100x100 (4:4:4) chroma plane, which is then
     * downscaled to the required 50x50.
     *
     * Without this flag, the chroma plane is instead generated at 50x100 (dropping
     * every other pixel), before then being downscaled to the required 50x50
     * resolution.
     */
    SWS_FULL_CHR_H_INP = 1 << 14,

    /**
     * Force bit-exact output. This will prevent the use of platform-specific
     * optimizations that may lead to slight difference in rounding, in favor
     * of always maintaining exact bit output compatibility with the reference
     * C code.
     *
     * Note: It is recommended to set both of these flags simultaneously.
     */
    SWS_ACCURATE_RND   = 1 << 18,
    SWS_BITEXACT       = 1 << 19,

    /**
     * Deprecated flags.
     */
    /** This flag has no effect */
    SWS_DIRECT_BGR      = 1 << 15,
    /** Set {@code SwsContext.dither} instead */
    SWS_ERROR_DIFFUSION = 1 << 23;

/** enum SwsIntent */
public static final int
    /** Perceptual tone mapping */
    SWS_INTENT_PERCEPTUAL = 0,
    /** Relative colorimetric clipping */
    SWS_INTENT_RELATIVE_COLORIMETRIC = 1,
    /** Saturation mapping */
    SWS_INTENT_SATURATION = 2,
    /** Absolute colorimetric clipping */
    SWS_INTENT_ABSOLUTE_COLORIMETRIC = 3,
    /** not part of the ABI */
    SWS_INTENT_NB = 4;
// Targeting ../swscale/SwsContext.java



/**
 * Allocate an empty SwsContext and set its fields to default values.
 */
@NoException public static native SwsContext sws_alloc_context();

/**
 * Free the context and everything associated with it, and write NULL
 * to the provided pointer.
 */
@NoException public static native void sws_free_context(@Cast("SwsContext**") PointerPointer ctx);
@NoException public static native void sws_free_context(@ByPtrPtr SwsContext ctx);

/***************************
 * Supported frame formats *
 ***************************/

/**
 * Test if a given pixel format is supported.
 *
 * @param output  If 0, test if compatible with the source/input frame;
 *                otherwise, with the destination/output frame.
 * @param format  The format to check.
 *
 * @return A positive integer if supported, 0 otherwise.
 */
@NoException public static native int sws_test_format(@Cast("AVPixelFormat") int format, int output);

/**
 * Test if a given color space is supported.
 *
 * @param output  If 0, test if compatible with the source/input frame;
 *                otherwise, with the destination/output frame.
 * @param colorspace The colorspace to check.
 *
 * @return A positive integer if supported, 0 otherwise.
 */
@NoException public static native int sws_test_colorspace(@Cast("AVColorSpace") int colorspace, int output);

/**
 * Test if a given set of color primaries is supported.
 *
 * @param output  If 0, test if compatible with the source/input frame;
 *                otherwise, with the destination/output frame.
 * @param primaries The color primaries to check.
 *
 * @return A positive integer if supported, 0 otherwise.
 */
@NoException public static native int sws_test_primaries(@Cast("AVColorPrimaries") int primaries, int output);

/**
 * Test if a given color transfer function is supported.
 *
 * @param output  If 0, test if compatible with the source/input frame;
 *                otherwise, with the destination/output frame.
 * @param trc     The color transfer function to check.
 *
 * @return A positive integer if supported, 0 otherwise.
 */
@NoException public static native int sws_test_transfer(@Cast("AVColorTransferCharacteristic") int trc, int output);

/**
 * Helper function to run all sws_test_* against a frame, as well as testing
 * the basic frame properties for sanity. Ignores irrelevant properties - for
 * example, AVColorSpace is not checked for RGB frames.
 */
@NoException public static native int sws_test_frame(@Const AVFrame frame, int output);

/**
 * Like {@code sws_scale_frame}, but without actually scaling. It will instead
 * merely initialize internal state that *would* be required to perform the
 * operation, as well as returning the correct error code for unsupported
 * frame combinations.
 *
 * @param ctx   The scaling context.
 * @param dst   The destination frame to consider.
 * @param src   The source frame to consider.
 * @return 0 on success, a negative AVERROR code on failure.
 */
@NoException public static native int sws_frame_setup(SwsContext ctx, @Const AVFrame dst, @Const AVFrame src);

/********************
 * Main scaling API *
 ********************/

/**
 * Check if a given conversion is a noop. Returns a positive integer if
 * no operation needs to be performed, 0 otherwise.
 */
@NoException public static native int sws_is_noop(@Const AVFrame dst, @Const AVFrame src);

/**
 * Scale source data from {@code src} and write the output to {@code dst}.
 *
 * This function can be used directly on an allocated context, without setting
 * up any frame properties or calling {@code sws_init_context()}. Such usage is fully
 * dynamic and does not require reallocation if the frame properties change.
 *
 * Alternatively, this function can be called on a context that has been
 * explicitly initialized. However, this is provided only for backwards
 * compatibility. In this usage mode, all frame properties must be correctly
 * set at init time, and may no longer change after initialization.
 *
 * @param ctx   The scaling context.
 * @param dst   The destination frame. The data buffers may either be already
 *              allocated by the caller or left clear, in which case they will
 *              be allocated by the scaler. The latter may have performance
 *              advantages - e.g. in certain cases some (or all) output planes
 *              may be references to input planes, rather than copies.
 * @param src   The source frame. If the data buffers are set to NULL, then
 *              this function behaves identically to {@code sws_frame_setup}.
 * @return >= 0 on success, a negative AVERROR code on failure.
 */
@NoException public static native int sws_scale_frame(SwsContext c, AVFrame dst, @Const AVFrame src);

/*************************
 * Legacy (stateful) API *
 *************************/

public static final int SWS_SRC_V_CHR_DROP_MASK =     0x30000;
public static final int SWS_SRC_V_CHR_DROP_SHIFT =    16;

public static final int SWS_PARAM_DEFAULT =           123456;

public static final double SWS_MAX_REDUCE_CUTOFF = 0.002;

public static final int SWS_CS_ITU709 =         1;
public static final int SWS_CS_FCC =            4;
public static final int SWS_CS_ITU601 =         5;
public static final int SWS_CS_ITU624 =         5;
public static final int SWS_CS_SMPTE170M =      5;
public static final int SWS_CS_SMPTE240M =      7;
public static final int SWS_CS_DEFAULT =        5;
public static final int SWS_CS_BT2020 =         9;

/**
 * Return a pointer to yuv<->rgb coefficients for the given colorspace
 * suitable for sws_setColorspaceDetails().
 *
 * @param colorspace One of the SWS_CS_* macros. If invalid,
 * SWS_CS_DEFAULT is used.
 */
@NoException public static native @Const IntPointer sws_getCoefficients(int colorspace);
// Targeting ../swscale/SwsVector.java


// Targeting ../swscale/SwsFilter.java



/**
 * Return a positive value if pix_fmt is a supported input format, 0
 * otherwise.
 */
@NoException public static native int sws_isSupportedInput(@Cast("AVPixelFormat") int pix_fmt);

/**
 * Return a positive value if pix_fmt is a supported output format, 0
 * otherwise.
 */
@NoException public static native int sws_isSupportedOutput(@Cast("AVPixelFormat") int pix_fmt);

/**
 * @param pix_fmt [in] the pixel format
 * @return a positive value if an endianness conversion for pix_fmt is
 * supported, 0 otherwise.
 */
@NoException public static native int sws_isSupportedEndiannessConversion(@Cast("AVPixelFormat") int pix_fmt);

/**
 * Initialize the swscaler context sws_context.
 *
 * This function is considered deprecated, and provided only for backwards
 * compatibility with sws_scale() and sws_start_frame(). The preferred way to
 * use libswscale is to set all frame properties correctly and call
 * sws_scale_frame() directly, without explicitly initializing the context.
 *
 * @return zero or positive value on success, a negative value on
 * error
 */
@NoException public static native int sws_init_context(SwsContext sws_context, SwsFilter srcFilter, SwsFilter dstFilter);

/**
 * Free the swscaler context swsContext.
 * If swsContext is NULL, then does nothing.
 */
@NoException public static native void sws_freeContext(SwsContext swsContext);

/**
 * Allocate and return an SwsContext. You need it to perform
 * scaling/conversion operations using sws_scale().
 *
 * @param srcW the width of the source image
 * @param srcH the height of the source image
 * @param srcFormat the source image format
 * @param dstW the width of the destination image
 * @param dstH the height of the destination image
 * @param dstFormat the destination image format
 * @param flags specify which algorithm and options to use for rescaling
 * @param param extra parameters to tune the used scaler
 *              For SWS_BICUBIC param[0] and [1] tune the shape of the basis
 *              function, param[0] tunes f(1) and param[1] f´(1)
 *              For SWS_GAUSS param[0] tunes the exponent and thus cutoff
 *              frequency
 *              For SWS_LANCZOS param[0] tunes the width of the window function
 * @return a pointer to an allocated context, or NULL in case of error
 * \note this function is to be removed after a saner alternative is
 *       written
 */
@NoException public static native SwsContext sws_getContext(int srcW, int srcH, @Cast("AVPixelFormat") int srcFormat,
                           int dstW, int dstH, @Cast("AVPixelFormat") int dstFormat,
                           int flags, SwsFilter srcFilter,
                           SwsFilter dstFilter, @Const DoublePointer param);
@NoException public static native SwsContext sws_getContext(int srcW, int srcH, @Cast("AVPixelFormat") int srcFormat,
                           int dstW, int dstH, @Cast("AVPixelFormat") int dstFormat,
                           int flags, SwsFilter srcFilter,
                           SwsFilter dstFilter, @Const DoubleBuffer param);
@NoException public static native SwsContext sws_getContext(int srcW, int srcH, @Cast("AVPixelFormat") int srcFormat,
                           int dstW, int dstH, @Cast("AVPixelFormat") int dstFormat,
                           int flags, SwsFilter srcFilter,
                           SwsFilter dstFilter, @Const double[] param);

/**
 * Scale the image slice in srcSlice and put the resulting scaled
 * slice in the image in dst. A slice is a sequence of consecutive
 * rows in an image. Requires a context that has been previously
 * been initialized with sws_init_context().
 *
 * Slices have to be provided in sequential order, either in
 * top-bottom or bottom-top order. If slices are provided in
 * non-sequential order the behavior of the function is undefined.
 *
 * @param c         the scaling context previously created with
 *                  sws_getContext()
 * @param srcSlice  the array containing the pointers to the planes of
 *                  the source slice
 * @param srcStride the array containing the strides for each plane of
 *                  the source image
 * @param srcSliceY the position in the source image of the slice to
 *                  process, that is the number (counted starting from
 *                  zero) in the image of the first row of the slice
 * @param srcSliceH the height of the source slice, that is the number
 *                  of rows in the slice
 * @param dst       the array containing the pointers to the planes of
 *                  the destination image
 * @param dstStride the array containing the strides for each plane of
 *                  the destination image
 * @return          the height of the output slice
 */
@NoException public static native int sws_scale(SwsContext c, @Cast("const uint8_t*const*") PointerPointer srcSlice,
              @Const IntPointer srcStride, int srcSliceY, int srcSliceH,
              @Cast("uint8_t*const*") PointerPointer dst, @Const IntPointer dstStride);
@NoException public static native int sws_scale(SwsContext c, @Cast("const uint8_t*const*") @ByPtrPtr BytePointer srcSlice,
              @Const IntPointer srcStride, int srcSliceY, int srcSliceH,
              @Cast("uint8_t*const*") @ByPtrPtr BytePointer dst, @Const IntPointer dstStride);
@NoException public static native int sws_scale(SwsContext c, @Cast("const uint8_t*const*") @ByPtrPtr ByteBuffer srcSlice,
              @Const IntBuffer srcStride, int srcSliceY, int srcSliceH,
              @Cast("uint8_t*const*") @ByPtrPtr ByteBuffer dst, @Const IntBuffer dstStride);
@NoException public static native int sws_scale(SwsContext c, @Cast("const uint8_t*const*") @ByPtrPtr byte[] srcSlice,
              @Const int[] srcStride, int srcSliceY, int srcSliceH,
              @Cast("uint8_t*const*") @ByPtrPtr byte[] dst, @Const int[] dstStride);

/**
 * Initialize the scaling process for a given pair of source/destination frames.
 * Must be called before any calls to sws_send_slice() and sws_receive_slice().
 * Requires a context that has been previously been initialized with
 * sws_init_context().
 *
 * This function will retain references to src and dst, so they must both use
 * refcounted buffers (if allocated by the caller, in case of dst).
 *
 * @param c   The scaling context
 * @param dst The destination frame.
 *
 *            The data buffers may either be already allocated by the caller or
 *            left clear, in which case they will be allocated by the scaler.
 *            The latter may have performance advantages - e.g. in certain cases
 *            some output planes may be references to input planes, rather than
 *            copies.
 *
 *            Output data will be written into this frame in successful
 *            sws_receive_slice() calls.
 * @param src The source frame. The data buffers must be allocated, but the
 *            frame data does not have to be ready at this point. Data
 *            availability is then signalled by sws_send_slice().
 * @return 0 on success, a negative AVERROR code on failure
 *
 * @see sws_frame_end()
 */
@NoException public static native int sws_frame_start(SwsContext c, AVFrame dst, @Const AVFrame src);

/**
 * Finish the scaling process for a pair of source/destination frames previously
 * submitted with sws_frame_start(). Must be called after all sws_send_slice()
 * and sws_receive_slice() calls are done, before any new sws_frame_start()
 * calls.
 *
 * @param c   The scaling context
 */
@NoException public static native void sws_frame_end(SwsContext c);

/**
 * Indicate that a horizontal slice of input data is available in the source
 * frame previously provided to sws_frame_start(). The slices may be provided in
 * any order, but may not overlap. For vertically subsampled pixel formats, the
 * slices must be aligned according to subsampling.
 *
 * @param c   The scaling context
 * @param slice_start first row of the slice
 * @param slice_height number of rows in the slice
 *
 * @return a non-negative number on success, a negative AVERROR code on failure.
 */
@NoException public static native int sws_send_slice(SwsContext c, @Cast("unsigned int") int slice_start,
                   @Cast("unsigned int") int slice_height);

/**
 * Request a horizontal slice of the output data to be written into the frame
 * previously provided to sws_frame_start().
 *
 * @param c   The scaling context
 * @param slice_start first row of the slice; must be a multiple of
 *                    sws_receive_slice_alignment()
 * @param slice_height number of rows in the slice; must be a multiple of
 *                     sws_receive_slice_alignment(), except for the last slice
 *                     (i.e. when slice_start+slice_height is equal to output
 *                     frame height)
 *
 * @return a non-negative number if the data was successfully written into the output
 *         AVERROR(EAGAIN) if more input data needs to be provided before the
 *                         output can be produced
 *         another negative AVERROR code on other kinds of scaling failure
 */
@NoException public static native int sws_receive_slice(SwsContext c, @Cast("unsigned int") int slice_start,
                      @Cast("unsigned int") int slice_height);

/**
 * Get the alignment required for slices. Requires a context that has been
 * previously been initialized with sws_init_context().
 *
 * @param c   The scaling context
 * @return alignment required for output slices requested with sws_receive_slice().
 *         Slice offsets and sizes passed to sws_receive_slice() must be
 *         multiples of the value returned from this function.
 */
@NoException public static native @Cast("unsigned int") int sws_receive_slice_alignment(@Const SwsContext c);

/**
 * @param c the scaling context
 * @param dstRange flag indicating the while-black range of the output (1=jpeg / 0=mpeg)
 * @param srcRange flag indicating the while-black range of the input (1=jpeg / 0=mpeg)
 * @param table the yuv2rgb coefficients describing the output yuv space, normally ff_yuv2rgb_coeffs[x]
 * @param inv_table the yuv2rgb coefficients describing the input yuv space, normally ff_yuv2rgb_coeffs[x]
 * @param brightness 16.16 fixed point brightness correction
 * @param contrast 16.16 fixed point contrast correction
 * @param saturation 16.16 fixed point saturation correction
 *
 * @return A negative error code on error, non negative otherwise.
 *         If {@code LIBSWSCALE_VERSION_MAJOR < 7}, returns -1 if not supported.
 */
@NoException public static native int sws_setColorspaceDetails(SwsContext c, @Const IntPointer inv_table,
                             int srcRange, @Const IntPointer table, int dstRange,
                             int brightness, int contrast, int saturation);
@NoException public static native int sws_setColorspaceDetails(SwsContext c, @Const IntBuffer inv_table,
                             int srcRange, @Const IntBuffer table, int dstRange,
                             int brightness, int contrast, int saturation);
@NoException public static native int sws_setColorspaceDetails(SwsContext c, @Const int[] inv_table,
                             int srcRange, @Const int[] table, int dstRange,
                             int brightness, int contrast, int saturation);

/**
 * @return A negative error code on error, non negative otherwise.
 *         If {@code LIBSWSCALE_VERSION_MAJOR < 7}, returns -1 if not supported.
 */
@NoException public static native int sws_getColorspaceDetails(SwsContext c, @Cast("int**") PointerPointer inv_table,
                             IntPointer srcRange, @Cast("int**") PointerPointer table, IntPointer dstRange,
                             IntPointer brightness, IntPointer contrast, IntPointer saturation);
@NoException public static native int sws_getColorspaceDetails(SwsContext c, @ByPtrPtr IntPointer inv_table,
                             IntPointer srcRange, @ByPtrPtr IntPointer table, IntPointer dstRange,
                             IntPointer brightness, IntPointer contrast, IntPointer saturation);
@NoException public static native int sws_getColorspaceDetails(SwsContext c, @ByPtrPtr IntBuffer inv_table,
                             IntBuffer srcRange, @ByPtrPtr IntBuffer table, IntBuffer dstRange,
                             IntBuffer brightness, IntBuffer contrast, IntBuffer saturation);
@NoException public static native int sws_getColorspaceDetails(SwsContext c, @ByPtrPtr int[] inv_table,
                             int[] srcRange, @ByPtrPtr int[] table, int[] dstRange,
                             int[] brightness, int[] contrast, int[] saturation);

/**
 * Allocate and return an uninitialized vector with length coefficients.
 */
@NoException public static native SwsVector sws_allocVec(int length);

/**
 * Return a normalized Gaussian curve used to filter stuff
 * quality = 3 is high quality, lower is lower quality.
 */
@NoException public static native SwsVector sws_getGaussianVec(double variance, double quality);

/**
 * Scale all the coefficients of a by the scalar value.
 */
@NoException public static native void sws_scaleVec(SwsVector a, double scalar);

/**
 * Scale all the coefficients of a so that their sum equals height.
 */
@NoException public static native void sws_normalizeVec(SwsVector a, double height);

@NoException public static native void sws_freeVec(SwsVector a);

@NoException public static native SwsFilter sws_getDefaultFilter(float lumaGBlur, float chromaGBlur,
                                float lumaSharpen, float chromaSharpen,
                                float chromaHShift, float chromaVShift,
                                int verbose);
@NoException public static native void sws_freeFilter(SwsFilter filter);

/**
 * Check if context can be reused, otherwise reallocate a new one.
 *
 * If context is NULL, just calls sws_getContext() to get a new
 * context. Otherwise, checks if the parameters are the ones already
 * saved in context. If that is the case, returns the current
 * context. Otherwise, frees context and gets a new context with
 * the new parameters.
 *
 * Be warned that srcFilter and dstFilter are not checked, they
 * are assumed to remain the same.
 */
@NoException public static native SwsContext sws_getCachedContext(SwsContext context, int srcW, int srcH,
                                 @Cast("AVPixelFormat") int srcFormat, int dstW, int dstH,
                                 @Cast("AVPixelFormat") int dstFormat, int flags,
                                 SwsFilter srcFilter, SwsFilter dstFilter,
                                 @Const DoublePointer param);
@NoException public static native SwsContext sws_getCachedContext(SwsContext context, int srcW, int srcH,
                                 @Cast("AVPixelFormat") int srcFormat, int dstW, int dstH,
                                 @Cast("AVPixelFormat") int dstFormat, int flags,
                                 SwsFilter srcFilter, SwsFilter dstFilter,
                                 @Const DoubleBuffer param);
@NoException public static native SwsContext sws_getCachedContext(SwsContext context, int srcW, int srcH,
                                 @Cast("AVPixelFormat") int srcFormat, int dstW, int dstH,
                                 @Cast("AVPixelFormat") int dstFormat, int flags,
                                 SwsFilter srcFilter, SwsFilter dstFilter,
                                 @Const double[] param);

/**
 * Convert an 8-bit paletted frame into a frame with a color depth of 32 bits.
 *
 * The output frame will have the same packed format as the palette.
 *
 * @param src        source frame buffer
 * @param dst        destination frame buffer
 * @param num_pixels number of pixels to convert
 * @param palette    array with [256] entries, which must match color arrangement (RGB or BGR) of src
 */
@NoException public static native void sws_convertPalette8ToPacked32(@Cast("const uint8_t*") BytePointer src, @Cast("uint8_t*") BytePointer dst, int num_pixels, @Cast("const uint8_t*") BytePointer palette);
@NoException public static native void sws_convertPalette8ToPacked32(@Cast("const uint8_t*") ByteBuffer src, @Cast("uint8_t*") ByteBuffer dst, int num_pixels, @Cast("const uint8_t*") ByteBuffer palette);
@NoException public static native void sws_convertPalette8ToPacked32(@Cast("const uint8_t*") byte[] src, @Cast("uint8_t*") byte[] dst, int num_pixels, @Cast("const uint8_t*") byte[] palette);

/**
 * Convert an 8-bit paletted frame into a frame with a color depth of 24 bits.
 *
 * With the palette format "ABCD", the destination frame ends up with the format "ABC".
 *
 * @param src        source frame buffer
 * @param dst        destination frame buffer
 * @param num_pixels number of pixels to convert
 * @param palette    array with [256] entries, which must match color arrangement (RGB or BGR) of src
 */
@NoException public static native void sws_convertPalette8ToPacked24(@Cast("const uint8_t*") BytePointer src, @Cast("uint8_t*") BytePointer dst, int num_pixels, @Cast("const uint8_t*") BytePointer palette);
@NoException public static native void sws_convertPalette8ToPacked24(@Cast("const uint8_t*") ByteBuffer src, @Cast("uint8_t*") ByteBuffer dst, int num_pixels, @Cast("const uint8_t*") ByteBuffer palette);
@NoException public static native void sws_convertPalette8ToPacked24(@Cast("const uint8_t*") byte[] src, @Cast("uint8_t*") byte[] dst, int num_pixels, @Cast("const uint8_t*") byte[] palette);

/**
 * \}
 */

// #endif /* SWSCALE_SWSCALE_H */


// Parsed from <libswscale/version_major.h>

/*
 * This file is part of FFmpeg.
 *
 * FFmpeg is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * FFmpeg is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with FFmpeg; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

// #ifndef SWSCALE_VERSION_MAJOR_H
// #define SWSCALE_VERSION_MAJOR_H

/**
 * \file
 * swscale version macros
 */

public static final int LIBSWSCALE_VERSION_MAJOR =   9;

/**
 * FF_API_* defines may be placed below to indicate public API that will be
 * dropped at a future version bump. The defines themselves are not part of
 * the public API and may change, break or disappear at any time.
 */

// #endif /* SWSCALE_VERSION_MAJOR_H */


// Parsed from <libswscale/version.h>

/*
 * This file is part of FFmpeg.
 *
 * FFmpeg is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * FFmpeg is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with FFmpeg; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

// #ifndef SWSCALE_VERSION_H
// #define SWSCALE_VERSION_H

/**
 * \file
 * swscale version macros
 */

// #include "libavutil/version.h"

// #include "version_major.h"

public static final int LIBSWSCALE_VERSION_MINOR =   1;
public static final int LIBSWSCALE_VERSION_MICRO = 100;

public static native @MemberGetter int LIBSWSCALE_VERSION_INT();
public static final int LIBSWSCALE_VERSION_INT = LIBSWSCALE_VERSION_INT();
// #define LIBSWSCALE_VERSION      AV_VERSION(LIBSWSCALE_VERSION_MAJOR,
//                                            LIBSWSCALE_VERSION_MINOR,
//                                            LIBSWSCALE_VERSION_MICRO)
public static final int LIBSWSCALE_BUILD =        LIBSWSCALE_VERSION_INT;

public static native @MemberGetter String LIBSWSCALE_IDENT();
public static final String LIBSWSCALE_IDENT = LIBSWSCALE_IDENT();

// #endif /* SWSCALE_VERSION_H */


}
