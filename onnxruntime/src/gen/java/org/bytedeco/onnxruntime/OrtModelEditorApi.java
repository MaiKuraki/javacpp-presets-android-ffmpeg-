// Targeted by JavaCPP version 1.5.13-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.onnxruntime;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;
import org.bytedeco.opencl.*;
import static org.bytedeco.opencl.global.OpenCL.*;
import org.bytedeco.dnnl.*;
import static org.bytedeco.dnnl.global.dnnl.*;

import static org.bytedeco.onnxruntime.global.onnxruntime.*;


/**
 * ORT Model Editor API
 */

/**
 * \brief The OrtModelEditorApi struct provides functions to create or edit an ONNX model.
 *
 * See onnxruntime/test/shared_lib/test_model_editor_api.cc for example usage.
 *
 * @since Version 1.22.
 */
@Properties(inherit = org.bytedeco.onnxruntime.presets.onnxruntime.class)
public class OrtModelEditorApi extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public OrtModelEditorApi() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public OrtModelEditorApi(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OrtModelEditorApi(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public OrtModelEditorApi position(long position) {
        return (OrtModelEditorApi)super.position(position);
    }
    @Override public OrtModelEditorApi getPointer(long i) {
        return new OrtModelEditorApi((Pointer)this).offsetAddress(i);
    }

  // Model building/editing requires a full build. We return nullptr from GetModelEditorApi if this is a minimal
  // build, so it doesn't matter if there are no function pointers in this struct as a user will never get an
  // OrtModelEditorApi instance. We do however need a dummy field to avoid empty struct warning.
// #if defined(ORT_MINIMAL_BUILD)
// #else
  /** \brief Create an OrtTypeInfo instance for a Tensor.
   *
   * Create an OrtTypeInfo instance for a Tensor to use as graph inputs/outputs with the Model Editor API.
   *
   * User can release {@code tensor_info} after creating the OrtTypeInfo.
   *
   * @param tensor_info [in] Tensor type and shape information.
   * @param type_info [out] TypeInfo instance for the tensor.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.22.
   */
  public native OrtStatus CreateTensorTypeInfo( @Const OrtTensorTypeAndShapeInfo tensor_info,
                    @Cast("OrtTypeInfo**") PointerPointer type_info);
  public native OrtStatus CreateTensorTypeInfo( @Const OrtTensorTypeAndShapeInfo tensor_info,
                    @ByPtrPtr OrtTypeInfo type_info);

  /** \brief Create an OrtTypeInfo instance for a SparseTensor.
   *
   * Create an OrtTypeInfo instance for a SparseTensor to use as graph inputs/outputs with the Model Editor API.
   *
   * User can release {@code tensor_info} after creating the OrtTypeInfo.
   *
   * @param tensor_info [in] SparseTensor type and shape information.
   * @param type_info [out] TypeInfo instance for the tensor.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.22.
   */
  public native OrtStatus CreateSparseTensorTypeInfo( @Const OrtTensorTypeAndShapeInfo tensor_info,
                    @Cast("OrtTypeInfo**") PointerPointer type_info);
  public native OrtStatus CreateSparseTensorTypeInfo( @Const OrtTensorTypeAndShapeInfo tensor_info,
                    @ByPtrPtr OrtTypeInfo type_info);

  /** \brief Create an OrtTypeInfo instance for a Map.
   *
   * Create an OrtTypeInfo instance for a Map to use as graph inputs/outputs with the Model Editor API.
   *
   * User can release {@code map_value_type} after creating the OrtTypeInfo.
   *
   * @param map_key_type [in] Key type for the map.
   * @param map_value_type [in] Value type for the map.
   * @param type_info [out] TypeInfo instance for the map.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.22.
   */
  public native OrtStatus CreateMapTypeInfo( @Cast("ONNXTensorElementDataType") int map_key_type, @Const OrtTypeInfo map_value_type,
                    @Cast("OrtTypeInfo**") PointerPointer type_info);
  public native OrtStatus CreateMapTypeInfo( @Cast("ONNXTensorElementDataType") int map_key_type, @Const OrtTypeInfo map_value_type,
                    @ByPtrPtr OrtTypeInfo type_info);

  /** \brief Create an OrtTypeInfo instance for a Sequence.
   *
   * Create an OrtTypeInfo instance for a Sequence to use as graph inputs/outputs with the Model Editor API.
   *
   * User can release {@code sequence_type} after creating the OrtTypeInfo.
   *
   * @param sequence_type [in] Sequence type and shape information.
   * @param type_info [out] TypeInfo instance for the sequence.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.22.
   */
  public native OrtStatus CreateSequenceTypeInfo( @Const OrtTypeInfo sequence_type, @Cast("OrtTypeInfo**") PointerPointer type_info);
  public native OrtStatus CreateSequenceTypeInfo( @Const OrtTypeInfo sequence_type, @ByPtrPtr OrtTypeInfo type_info);

  /** \brief Create an OrtTypeInfo instance for an Optional.
   *
   * Create an OrtTypeInfo instance for an Optional to use as graph inputs/outputs with the Model Editor API.
   *
   * User can release {@code contained_type} after creating the OrtTypeInfo.
   *
   * @param contained_type [in] Tensor type and shape information.
   * @param type_info [out] TypeInfo instance for the tensor.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.22.
   */
  public native OrtStatus CreateOptionalTypeInfo( @Const OrtTypeInfo contained_type, @Cast("OrtTypeInfo**") PointerPointer type_info);
  public native OrtStatus CreateOptionalTypeInfo( @Const OrtTypeInfo contained_type, @ByPtrPtr OrtTypeInfo type_info);

  /** \brief Create an OrtValueInfo for use as an OrtGraph input or output.
   *
   * @param name [in] The name of the input or output.
   * @param type_info [in] The type information for the input or output. The provided value is copied.
   * @param value_info [out] The OrtValueInfo instance.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.22.
   */
  public native OrtStatus CreateValueInfo( @Cast("const char*") BytePointer name, @Const OrtTypeInfo type_info,
                    @Cast("OrtValueInfo**") PointerPointer value_info);
  public native OrtStatus CreateValueInfo( @Cast("const char*") BytePointer name, @Const OrtTypeInfo type_info,
                    @ByPtrPtr OrtValueInfo value_info);
  public native OrtStatus CreateValueInfo( String name, @Const OrtTypeInfo type_info,
                    @ByPtrPtr OrtValueInfo value_info);

  /** \brief Create an OrtNode to add to an OrtGraph.
   *
   * Create an OrtNode.
   *
   * Create attributes with CreateOpAttr. OrtOpAttr instances are copied.
   *
   * @param operator_name [in] The name of the operator.
   * @param domain_name [in] The domain of the operator. Use an empty string for ONNX operators.
   * @param node_name [in] The name of the node.
   * @param input_names [in] The names of the inputs.
   * @param input_names_len [in] The number of input names.
   * @param output_names [in] The names of the outputs.
   * @param output_names_len [in] The number of output names.
   * @param attributes [in] The optional attributes of the node.
   * @param attribs_len [in] The number of attributes. May be zero.
   * @param node [out] The OrtNode instance.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.22.
   */
  public native OrtStatus CreateNode( @Cast("const char*") BytePointer operator_name, @Cast("const char*") BytePointer domain_name, @Cast("const char*") BytePointer node_name,
                    @Cast("const char*const*") PointerPointer input_names, @Cast("size_t") long input_names_len,
                    @Cast("const char*const*") PointerPointer output_names, @Cast("size_t") long output_names_len,
                    @Cast("OrtOpAttr**") PointerPointer attributes, @Cast("size_t") long attribs_len,
                    @Cast("OrtNode**") PointerPointer node);
  public native OrtStatus CreateNode( @Cast("const char*") BytePointer operator_name, @Cast("const char*") BytePointer domain_name, @Cast("const char*") BytePointer node_name,
                    @Cast("const char*const*") @ByPtrPtr BytePointer input_names, @Cast("size_t") long input_names_len,
                    @Cast("const char*const*") @ByPtrPtr BytePointer output_names, @Cast("size_t") long output_names_len,
                    @ByPtrPtr OrtOpAttr attributes, @Cast("size_t") long attribs_len,
                    @ByPtrPtr OrtNode node);
  public native OrtStatus CreateNode( String operator_name, String domain_name, String node_name,
                    @Cast("const char*const*") @ByPtrPtr ByteBuffer input_names, @Cast("size_t") long input_names_len,
                    @Cast("const char*const*") @ByPtrPtr ByteBuffer output_names, @Cast("size_t") long output_names_len,
                    @ByPtrPtr OrtOpAttr attributes, @Cast("size_t") long attribs_len,
                    @ByPtrPtr OrtNode node);
  public native OrtStatus CreateNode( @Cast("const char*") BytePointer operator_name, @Cast("const char*") BytePointer domain_name, @Cast("const char*") BytePointer node_name,
                    @Cast("const char*const*") @ByPtrPtr byte[] input_names, @Cast("size_t") long input_names_len,
                    @Cast("const char*const*") @ByPtrPtr byte[] output_names, @Cast("size_t") long output_names_len,
                    @ByPtrPtr OrtOpAttr attributes, @Cast("size_t") long attribs_len,
                    @ByPtrPtr OrtNode node);
  public native OrtStatus CreateNode( String operator_name, String domain_name, String node_name,
                    @Cast("const char*const*") @ByPtrPtr BytePointer input_names, @Cast("size_t") long input_names_len,
                    @Cast("const char*const*") @ByPtrPtr BytePointer output_names, @Cast("size_t") long output_names_len,
                    @ByPtrPtr OrtOpAttr attributes, @Cast("size_t") long attribs_len,
                    @ByPtrPtr OrtNode node);
  public native OrtStatus CreateNode( @Cast("const char*") BytePointer operator_name, @Cast("const char*") BytePointer domain_name, @Cast("const char*") BytePointer node_name,
                    @Cast("const char*const*") @ByPtrPtr ByteBuffer input_names, @Cast("size_t") long input_names_len,
                    @Cast("const char*const*") @ByPtrPtr ByteBuffer output_names, @Cast("size_t") long output_names_len,
                    @ByPtrPtr OrtOpAttr attributes, @Cast("size_t") long attribs_len,
                    @ByPtrPtr OrtNode node);
  public native OrtStatus CreateNode( String operator_name, String domain_name, String node_name,
                    @Cast("const char*const*") @ByPtrPtr byte[] input_names, @Cast("size_t") long input_names_len,
                    @Cast("const char*const*") @ByPtrPtr byte[] output_names, @Cast("size_t") long output_names_len,
                    @ByPtrPtr OrtOpAttr attributes, @Cast("size_t") long attribs_len,
                    @ByPtrPtr OrtNode node);

  /** \brief Create an OrtGraph
   * \snippet{doc} snippets.dox OrtStatus Return Value
   * @since Version 1.22.
   */
  public native OrtStatus CreateGraph( @Cast("OrtGraph**") PointerPointer graph);
  public native OrtStatus CreateGraph( @ByPtrPtr OrtGraph graph);

  /** \brief Set the inputs for the OrtGraph.
   *
   * Set the graph inputs. This will replace any existing inputs with the new values.
   * The OrtGraph takes ownership of the OrtValueInfo instances and you should NOT call ReleaseOrtValueInfo.
   *
   * @param graph [in] The OrtGraph instance to update.
   * @param inputs [in] The input OrtValueInfo instances.
   * @param inputs_len [in] The number of input OrtValueInfo instances.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.22.
   */
  public native OrtStatus SetGraphInputs( OrtGraph graph,
                    @Cast("OrtValueInfo**") PointerPointer inputs, @Cast("size_t") long inputs_len);
  public native OrtStatus SetGraphInputs( OrtGraph graph,
                    @ByPtrPtr OrtValueInfo inputs, @Cast("size_t") long inputs_len);

  /** \brief Set the outputs for the OrtGraph.
   *
   * Set the graph outputs. This will replace any existing outputs with the new values.
   * The OrtGraph takes ownership of the OrtValueInfo instances provided and you should NOT call ReleaseOrtValueInfo.
   *
   * @param graph [in] The OrtGraph instance to update.
   * @param outputs [in] The output OrtValueInfo instances.
   * @param outputs_len [in] The number of output OrtValueInfo instances.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.22.
   */
  public native OrtStatus SetGraphOutputs( OrtGraph graph,
                    @Cast("OrtValueInfo**") PointerPointer outputs, @Cast("size_t") long outputs_len);
  public native OrtStatus SetGraphOutputs( OrtGraph graph,
                    @ByPtrPtr OrtValueInfo outputs, @Cast("size_t") long outputs_len);

  /** \brief Add an initializer to the OrtGraph
   *
   * ORT will take ownership of the OrtValue and you should NOT call ReleaseOrtValue.
   *
   * Two options:
   *
   * Allocated memory:
   *    Use CreateTensorAsOrtValue (allocates memory) and populate the tensor with the data.
   *    Set {@code data_is_external} to false.
   *
   * Pre-existing memory:
   *    Use CreateTensorWithDataAsOrtValue or CreateTensorWithDataAndDeleterAsOrtValue to create an OrtValue
   *    with a tensor that contains a pointer to the existing data.
   *    Set {@code data_is_external} to true.
   *
   *    The pointer must remain valid for the duration of the inference session.
   *    If using CreateTensorWithDataAsOrtValue you are responsible for freeing the memory after the inference session
   *    is released.
   *    If using CreateTensorWithDataAndDeleterAsOrtValue, ORT will free the memory using the provided deleter as
   *    soon as the OrtValue is no longer in use.
   *
   *    NOTE: A tensor containing pre-existing memory MUST have 128 bytes of data or more.
   *          For smaller tensors use CreateTensorAsOrtValue.
   *
   *          ONNX shape inferencing does not support external data. An initializer involved in shape inferencing is
   *          typically small (a single value or limited by the rank of a tensor) and uses less than 128 bytes of
   *          memory, so this limit acts as a simple catch-all rule to avoid issues.
   *          e.g. Reshape's {@code shape}, Clip's {@code min} and {@code max}, various ops {@code axes}.
   *
   * @param graph [in] The OrtGraph instance to update.
   * @param name [in] The value name for the initializer.
   * @param tensor [in] The OrtValue instance containing the tensor data.
   * @param data_is_external [in] Set to true if the data is external and should not be copied.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.22.
   */
  public native OrtStatus AddInitializerToGraph( OrtGraph graph, @Cast("const char*") BytePointer name, OrtValue tensor,
                    @Cast("bool") boolean data_is_external);
  public native OrtStatus AddInitializerToGraph( OrtGraph graph, String name, OrtValue tensor,
                    @Cast("bool") boolean data_is_external);

  /** \brief Add an OrtNode to an OrtGraph
   *
   * Add the node to the graph. The OrtGraph will take ownership of OrtNode and you should NOT call ReleaseOrtNode.
   *
   * @param graph [in] The OrtGraph instance to update.
   * @param node [in] The OrtNode instance to add to the graph.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.22.
   */
  public native OrtStatus AddNodeToGraph( OrtGraph graph, OrtNode node);

  /** \brief Create an OrtModel.
   *
   * Create an OrtModel.
   *
   * This can be used to build a new model, or to augment an existing model.
   *
   * @param domain_names [in] The domain names for the model.
   *                         If augmenting an existing model add additional domains if needed.
   * @param opset_versions [in] The opset versions for the model.
   *                           If augmenting an existing model add additional opset versions if needed.
   * @param opset_entries_len [in] The number of domain_names and opset_versions entries.
   *                              Domain and opset entries should be 1:1
   * @param model [out] The OrtModel instance.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.22.
   */
  public native OrtStatus CreateModel(
                    @Cast("const char*const*") PointerPointer domain_names,
                    @Const IntPointer opset_versions,
                    @Cast("size_t") long opset_entries_len,
                    @Cast("OrtModel**") PointerPointer model);
  public native OrtStatus CreateModel(
                    @Cast("const char*const*") @ByPtrPtr BytePointer domain_names,
                    @Const IntPointer opset_versions,
                    @Cast("size_t") long opset_entries_len,
                    @ByPtrPtr OrtModel model);
  public native OrtStatus CreateModel(
                    @Cast("const char*const*") @ByPtrPtr ByteBuffer domain_names,
                    @Const IntBuffer opset_versions,
                    @Cast("size_t") long opset_entries_len,
                    @ByPtrPtr OrtModel model);
  public native OrtStatus CreateModel(
                    @Cast("const char*const*") @ByPtrPtr byte[] domain_names,
                    @Const int[] opset_versions,
                    @Cast("size_t") long opset_entries_len,
                    @ByPtrPtr OrtModel model);

  /** \brief Add an OrtGraph to an OrtModel.
   *
   * Add the graph to a model. This should be called once when creating a new model.
   *
   * The OrtModel takes ownership of the OrtGraph and you should NOT call ReleaseOrtGraph.
   *
   * @param model [in] The OrtModel instance to update.
   * @param graph [in] The OrtGraph instance to add to the model.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.22.
   */
  public native OrtStatus AddGraphToModel( OrtModel model, OrtGraph graph);

  /** \brief Create an OrtSession using the OrtModel.
   *
   * Create an inference session using the OrtModel instance.
   * The OrtModel should have been populated with an OrtGraph containing nodes and initializers, and SetGraphInputs
   * and SetGraphOutputs must have been called.
   * This will validate the model, run optimizers, and prepare the session for inferencing.
   *
   * ReleaseOrtModel must be called to free the OrtModel after session creation.
   *
   * @param env [in] The OrtEnv instance.
   * @param model [in] The OrtModel instance.
   * @param options [in] The OrtSessionOptions instance.
   * @param out [out] The OrtSession instance.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.22.
   */
  public native OrtStatus CreateSessionFromModel( @Const OrtEnv env, @Const OrtModel model,
                    @Const OrtSessionOptions options, @Cast("OrtSession**") PointerPointer out);
  public native OrtStatus CreateSessionFromModel( @Const OrtEnv env, @Const OrtModel model,
                    @Const OrtSessionOptions options, @ByPtrPtr OrtSession out);

  /** \brief Create an OrtSession to augment an existing model.
   *
   * Create an OrtSession with an existing model that will be augmented with additional nodes and initializers.
   * Nodes can be added before or after the existing nodes in the model. ONNX Runtime will connect the nodes when the
   * model is finalized.
   *
   * To add nodes and initializers to the existing model, first create an OrtModel using CreateModel.
   * Add nodes and initializers to the OrtModel using AddNodeToGraph and AddInitializerToGraph.
   * Graph inputs/outputs should be updated with SetGraphInputs and SetGraphOutputs as needed to reflect changes made
   * by the new nodes. The list of graph inputs/outputs should be for the overall model and not just the new nodes.
   *
   * Add the new information from the OrtModel to the original model using ApplyModelToSession, and prepare the
   * session for inferencing by calling FinalizeModelEditorSession.
   *
   * @param {in} env The OrtEnv instance.
   * @param {in} model_path The path to the existing ONNX model to augment.
   * @param {in} options The OrtSessionOptions instance.
   * @param {out} out The created OrtSession instance.
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.22.
   */
  public native OrtStatus CreateModelEditorSession( @Const OrtEnv env, @Cast("const ORTCHAR_T*") Pointer model_path,
                    @Const OrtSessionOptions options,
                    @Cast("OrtSession**") PointerPointer out);
  public native OrtStatus CreateModelEditorSession( @Const OrtEnv env, @Cast("const ORTCHAR_T*") Pointer model_path,
                    @Const OrtSessionOptions options,
                    @ByPtrPtr OrtSession out);

  /** \brief Create an OrtSession to augment an existing model.
   *
   * Create an OrtSession with an existing model that will be augmented with additional nodes and initializers.
   * Nodes can be added before or after the existing nodes in the model. ONNX Runtime will connect the nodes when the
   * model is finalized.
   *
   * To add nodes and initializers to the existing model, first create an OrtModel using CreateModel.
   * Add nodes and initializers to the OrtModel using AddNodeToGraph and AddInitializerToGraph.
   * Graph inputs/outputs should be updated with SetGraphInputs and SetGraphOutputs as needed to reflect changes made
   * by the new nodes. The list of graph inputs/outputs should be for the overall model and not just the new nodes.
   *
   * Add the new information from the OrtModel to the original model using ApplyModelToSession, and prepare the
   * session for inferencing by calling FinalizeModelEditorSession.
   *
   * @param {in} env The OrtEnv instance.
   * @param {in} model_data The model data for the existing model to augment.
   * @param {in} model_data_length The length of the model data.
   * @param {in} options The OrtSessionOptions instance.
   * @param {out} out The created OrtSession instance.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.22.
   */
  public native OrtStatus CreateModelEditorSessionFromArray( @Const OrtEnv env,
                    @Const Pointer model_data, @Cast("size_t") long model_data_length,
                    @Const OrtSessionOptions options,
                    @Cast("OrtSession**") PointerPointer out);
  public native OrtStatus CreateModelEditorSessionFromArray( @Const OrtEnv env,
                    @Const Pointer model_data, @Cast("size_t") long model_data_length,
                    @Const OrtSessionOptions options,
                    @ByPtrPtr OrtSession out);

  /** \brief Query the session for the opset version of a domain.
   *
   * When using the Model Editor API to augment a model, any new nodes must conform to the opset version of the
   * original model. To do that the user must be able to discover that opset version.
   * Returns an error if the domain is not used in the model.
   *
   * @param session [in] OrtSession to query
   * @param domain [in] Domain to query. The ONNX domain is an empty string.
   * @param opset [out] The opset version of the domain.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.22.
   */
  public native OrtStatus SessionGetOpsetForDomain( @Const OrtSession session, @Cast("const char*") BytePointer domain, IntPointer opset);
  public native OrtStatus SessionGetOpsetForDomain( @Const OrtSession session, String domain, IntBuffer opset);
  public native OrtStatus SessionGetOpsetForDomain( @Const OrtSession session, @Cast("const char*") BytePointer domain, int[] opset);
  public native OrtStatus SessionGetOpsetForDomain( @Const OrtSession session, String domain, IntPointer opset);
  public native OrtStatus SessionGetOpsetForDomain( @Const OrtSession session, @Cast("const char*") BytePointer domain, IntBuffer opset);
  public native OrtStatus SessionGetOpsetForDomain( @Const OrtSession session, String domain, int[] opset);

  /** \brief Apply changes to augment the ONNX model in a session created using CreateModelEditorSession[FromArray]
   *
   * Adds new nodes and updates graph inputs/outputs using {@code model} to augment the original ONNX model in the session.
   * All changes will be validated.
   * Call FinalizeModelEditorSession to prepare the session for inferencing.
   *
   * Existing input/outputs will only be updated if the OrtGraph inputs/outputs are set in the OrtModel.
   *   i.e. you don't need to call SetGraphInputs/SetGraphOutputs if they are unchanged.
   *
   * ReleaseOrtModel must be called to free the OrtModel after it is applied to the session.
   *
   * @param session [in] OrtSession to update. Session must have been created using CreateModelEditorSession[FromArray].
   * @param model [in] OrtModel containing new nodes, new initializers, and updated graph input and/or output info.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.22.
   */
  public native OrtStatus ApplyModelToModelEditorSession( OrtSession session, OrtModel model);

  /** \brief Finalize the Model Editor session that was created using CreateModelEditorSession[FromArray].
   *
   * Finalize the Model Editor session that augmented an ONNX model by adding new nodes.
   * This will run optimizers and prepare the session for inferencing.
   *
   * @param session [in] OrtSession to finalize. Session must have been created using CreateModelEditorSession[FromArray].
   * @param options [in] OrtSessionOptions to use for the session.
   * @param prepacked_weights_container [in] Optional OrtPrepackedWeightsContainer to use for the session.
                Set to nullptr if not used.
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.22.
   */
  public native OrtStatus FinalizeModelEditorSession( OrtSession session, @Const OrtSessionOptions options,
                    OrtPrepackedWeightsContainer prepacked_weights_container);
// #endif  // !defined(ORT_MINIMAL_BUILD)
}
