// Targeted by JavaCPP version 1.5.13-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.opencv.opencv_calib3d;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;
import static org.bytedeco.openblas.global.openblas_nolapack.*;
import static org.bytedeco.openblas.global.openblas.*;
import org.bytedeco.opencv.opencv_core.*;
import static org.bytedeco.opencv.global.opencv_core.*;
import org.bytedeco.opencv.opencv_imgproc.*;
import static org.bytedeco.opencv.global.opencv_imgproc.*;
import static org.bytedeco.opencv.global.opencv_imgcodecs.*;
import org.bytedeco.opencv.opencv_videoio.*;
import static org.bytedeco.opencv.global.opencv_videoio.*;
import org.bytedeco.opencv.opencv_highgui.*;
import static org.bytedeco.opencv.global.opencv_highgui.*;
import org.bytedeco.opencv.opencv_flann.*;
import static org.bytedeco.opencv.global.opencv_flann.*;
import org.bytedeco.opencv.opencv_features2d.*;
import static org.bytedeco.opencv.global.opencv_features2d.*;

import static org.bytedeco.opencv.global.opencv_calib3d.*;



/**
 * \brief Class for computing stereo correspondence using the block matching algorithm, introduced and contributed to OpenCV by K. Konolige.
 * \details This class implements a block matching algorithm for stereo correspondence, which is used to compute disparity maps from stereo image pairs. It provides methods to fine-tune parameters such as pre-filtering, texture thresholds, uniqueness ratios, and regions of interest (ROIs) to optimize performance and accuracy.
 */
@Namespace("cv") @Properties(inherit = org.bytedeco.opencv.presets.opencv_calib3d.class)
public class StereoBM extends StereoMatcher {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public StereoBM(Pointer p) { super(p); }
    /** Downcast constructor. */
    public StereoBM(Algorithm pointer) { super((Pointer)null); allocate(pointer); }
    @Namespace private native @Name("static_cast<cv::StereoBM*>") void allocate(Algorithm pointer);

    /**
     * \brief Pre-filter types for the stereo matching algorithm.
     * \details These constants define the type of pre-filtering applied to the images before computing the disparity map.
     * - PREFILTER_NORMALIZED_RESPONSE: Uses normalized response for pre-filtering.
     * - PREFILTER_XSOBEL: Uses the X-Sobel operator for pre-filtering.
     */
    /** enum cv::StereoBM:: */
    public static final int
        /** Normalized response pre-filter */
        PREFILTER_NORMALIZED_RESPONSE = 0,
        /** X-Sobel pre-filter */
        PREFILTER_XSOBEL              = 1;

    /**
     * \brief Gets the type of pre-filtering currently used in the algorithm.
     * @return The current pre-filter type: 0 for PREFILTER_NORMALIZED_RESPONSE or 1 for PREFILTER_XSOBEL.
     */
    public native int getPreFilterType();

    /**
     * \brief Sets the type of pre-filtering used in the algorithm.
     * @param preFilterType The type of pre-filter to use. Possible values are:
     * - PREFILTER_NORMALIZED_RESPONSE (0): Uses normalized response for pre-filtering.
     * - PREFILTER_XSOBEL (1): Uses the X-Sobel operator for pre-filtering.
     * \details The pre-filter type affects how the images are prepared before computing the disparity map. Different pre-filtering methods can enhance specific image features or reduce noise, influencing the quality of the disparity map.
     */
    public native void setPreFilterType(int preFilterType);

    /**
     * \brief Gets the current size of the pre-filter kernel.
     * @return The current pre-filter size.
     */
    public native int getPreFilterSize();

    /**
     * \brief Sets the size of the pre-filter kernel.
     * @param preFilterSize The size of the pre-filter kernel. Must be an odd integer, typically between 5 and 255.
     * \details The pre-filter size determines the spatial extent of the pre-filtering operation, which prepares the images for disparity computation by normalizing brightness and enhancing texture. Larger sizes reduce noise but may blur details, while smaller sizes preserve details but are more susceptible to noise.
     */
    public native void setPreFilterSize(int preFilterSize);

    /**
     * \brief Gets the current truncation value for prefiltered pixels.
     * @return The current pre-filter cap value.
     */
    public native int getPreFilterCap();

    /**
     * \brief Sets the truncation value for prefiltered pixels.
     * @param preFilterCap The truncation value. Typically in the range [1, 63].
     * \details This value caps the output of the pre-filter to [-preFilterCap, preFilterCap], helping to reduce the impact of noise and outliers in the pre-filtered image.
     */
    public native void setPreFilterCap(int preFilterCap);

    /**
     * \brief Gets the current texture threshold value.
     * @return The current texture threshold.
     */
    public native int getTextureThreshold();

    /**
     * \brief Sets the threshold for filtering low-texture regions.
     * @param textureThreshold The threshold value. Must be non-negative.
     * \details This parameter filters out regions with low texture, where establishing correspondences is difficult, thus reducing noise in the disparity map. Higher values filter more aggressively but may discard valid information.
     */
    public native void setTextureThreshold(int textureThreshold);

    /**
     * \brief Gets the current uniqueness ratio value.
     * @return The current uniqueness ratio.
     */
    public native int getUniquenessRatio();

    /**
     * \brief Sets the uniqueness ratio for filtering ambiguous matches.
     * @param uniquenessRatio The uniqueness ratio value. Typically in the range [5, 15], but can be from 0 to 100.
     * \details This parameter ensures that the best match is sufficiently better than the next best match, reducing false positives. Higher values are stricter but may filter out valid matches in difficult regions.
     */
    public native void setUniquenessRatio(int uniquenessRatio);

    /**
     * \brief Gets the current size of the smaller block used for texture check.
     * @return The current smaller block size.
     */
    public native int getSmallerBlockSize();

    /**
     * \brief Sets the size of the smaller block used for texture check.
     * @param blockSize The size of the smaller block. Must be an odd integer between 5 and 255.
     * \details This parameter determines the size of the block used to compute texture variance. Smaller blocks capture finer details but are more sensitive to noise, while larger blocks are more robust but may miss fine details.
     */
    public native void setSmallerBlockSize(int blockSize);

    /**
     * \brief Gets the current Region of Interest (ROI) for the left image.
     * @return The current ROI for the left image.
     */
    public native @ByVal Rect getROI1();

    /**
     * \brief Sets the Region of Interest (ROI) for the left image.
     * @param roi1 The ROI rectangle for the left image.
     * \details By setting the ROI, the stereo matching computation is limited to the specified region, improving performance and potentially accuracy by focusing on relevant parts of the image.
     */
    public native void setROI1(@ByVal Rect roi1);

    /**
     * \brief Gets the current Region of Interest (ROI) for the right image.
     * @return The current ROI for the right image.
     */
    public native @ByVal Rect getROI2();

    /**
     * \brief Sets the Region of Interest (ROI) for the right image.
     * @param roi2 The ROI rectangle for the right image.
     * \details Similar to setROI1, this limits the computation to the specified region in the right image.
     */
    public native void setROI2(@ByVal Rect roi2);

    /**
     * \brief Creates StereoBM object
     * @param numDisparities The disparity search range. For each pixel, the algorithm will find the best disparity from 0 (default minimum disparity) to numDisparities. The search range can be shifted by changing the minimum disparity.
     * @param blockSize The linear size of the blocks compared by the algorithm. The size should be odd (as the block is centered at the current pixel). Larger block size implies smoother, though less accurate disparity map. Smaller block size gives more detailed disparity map, but there is a higher chance for the algorithm to find a wrong correspondence.
     * @return A pointer to the created StereoBM object.
     * \details The function creates a StereoBM object. You can then call StereoBM::compute() to compute disparity for a specific stereo pair.
     */
    public static native @Ptr StereoBM create(int numDisparities/*=0*/, int blockSize/*=21*/);
    public static native @Ptr StereoBM create();
}
